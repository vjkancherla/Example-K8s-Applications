=================================================================================================
STRUCTURING APPLICATION CODE, APPLICATION CONFIGURATION, AND INFRASTRUCTURE IN GIT REPOSITORIES
=================================================================================================

Source discussion: 
	- https://devops.stackexchange.com/questions/12803/best-practices-for-app-and-infrastructure-code-repositories


===================================
Option-1: MonoRepo
===================================

LAYERS:
	- The 3 layers of an organisation's IT operations are -- infrastructure, platform, and application. 
	
	- These 3 layers are blurred at the boundaries and there is a continual debate about their delineations, 
		but if you're not familiar with this model, roughly:

		- Infra: machines and VMs, security and resource groups, auto-scaling groups and elastic load-balancers -- 
		   stuff you typically provision with Terraform
		   
		- Platform: is Kubernetes cluster, OpenShift, IIS, etc. -- stuff you typically provision with Packer, kubectl, or helm 
			(and, this is the first blurring, because EKS, AKS, GKE, are often provisioned with terraform too)

		- Application: is the business logic and software that runs your business, confusingly this is also often provisioned 
			with kubectl or helm, and possibly packer if you're into the wonderful immutability model
			
			
TEAMS STRUCTURE:
	- we have centralised teams for infra and platform, and they distribute their output to the development teams 
		and we typically work with the cluster-per-app model. 
	
	- In modern orgs we work with a cross-functional team that has some skills in each of the areas we need, including DevOps, 
	  	and each team member is also a member of a group that is focused on their speciality where they receive groupwide instruction.
	  	

MONOREPOS:
	- all the code needed to build and deploy your application is contained in a single repo and versioned together. 
	
	- though you don't have to go deep into monorepo culture for this to apply. Simply maintaining a single version for 
		all your applications, infra, and platform will have the same effect.
	
	We have 2 main models to provide access to the output of the centralised infra and platform teams:

	[1] The infra and platform teams can provision clusters on behalf of a dev team and provide the pipelines needed to deploy applications to it. 
		This works well when a team has little or no DevOps capability, but it is far from being the best solution 
		as it creates a dependency from the dev team to the infra and platform teams which usually causes impedance and added complexity.

	[2] The infra and platform teams can provide access to their git repos, and the dev teams can fork them into 
	    git submodules within their own mono-repos. This model is by far the most common and currently represents the best 
	    solution for highly regulated industries. One of the biggest benefits here is that a dev team can make the changes 
	    they need to make (to the infra and platform) and issue pull-requests for the application teams to manage, 
	    without having to coordinate the schedules of the teams and thus reducing impedance.
	    
	    
	Solution 1 would require separate repos for infra, platform, and app, and this usually results in a need to synchronise 
	the backlogs of the respective teams, which quickly becomes a logistical nightmare as the number of teams increases. 
	
	Solution 2 would require the implementation of 'initial trust' base infra with something like Open Policy Agent (OPA) rules 
	to ensure that dev teams are complying with organisational governance requirements. (e.g. verifying that a dev team isn't 
	running a bitcoin mining operation, or publishing pro-trump/fascist/racist propaganda to our public-facing websites).
	

VERSIONING:
	- we talk about which version of what software/hardware work together?
	
	The configuration management problem is largely solved with a monorepo. You'll never hear anyone say 
	"I tried to deploy your software but you've written a helm 3 chart and our cluster only has helm 2 installed," 
	or, "we patched the OS with the latest security updates and your application crashed." 
	With a monorepo, as long as you have sufficient testing in place, your helm version will always be in sync with 
	your helm files and your software will have always been tested with the latest security patches.


TEAM DEPENDENCIES:
	- If there are 300 dev teams, an infrastructure team will be continually inundated with requests for changes 
	  that must be understood, managed, prioritised, and scheduled -- this is a major effort in large orgs and can 
	  leave a team waiting months, or longer, for changes that support their needs, leading to project delays.
	  
	- if the centralised team is working on your problem then they're not working on someone else's, so either 
		you are delayed or the other 300 teams are. There are always 299 teams waiting to be serviced.
		
	- Monorepos with git's submodules (or similar structures) help fix this problem. Dev teams can make their own 
	  changes to their forked codebase and simply have it reviewed by an authorised representative of the centralised team 
	  and pull-requests can be used to manage this process.
	  
	  
	  
===================
Option-2: REPO PER LAYER: App Src, App deployment mainfests (Helm), App IaC dependencies (RDS, etc), Platfrom (EKS)
====================

- The Continuous Delivery book use a repository for application source code and a separate repository for application configuration. 

- The repo for application configuration contains the environment-specific configuration for the app, for each environment (e.g. test, staging and prod).

- When apps are deployed using some form of IaC e.g. Terraform or Kubernetes manifests, this lives in the repo for application configuration.

FOR THE REST, see second comment in -> https://devops.stackexchange.com/questions/12803/best-practices-for-app-and-infrastructure-code-repositories


